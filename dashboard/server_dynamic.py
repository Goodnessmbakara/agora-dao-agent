#!/usr/bin/env python3
"""
AI-Powered Dynamic Dashboard Server for Agora
Generates realistic proposals using Bedrock Claude
"""

import http.server
import socketserver
import json
import os
import sys
from datetime import datetime
from pathlib import Path

# Add parent directory to path
sys.path.insert(0, str(Path(__file__).parent.parent))

from src.dynamic_proposals import DynamicProposalGenerator

class AgoraDynamicHandler(http.server.SimpleHTTPRequestHandler):
    """Handler with AI-generated proposals"""
    
    # Shared cache for proposals (regenerate every 5 minutes)
    cached_proposals = []
    last_generated = None
    generator = None
    
    def __init__(self, *args, **kwargs):
        # Initialize generator on first request
        if AgoraDynamicHandler.generator is None:
            print("ü§ñ Initializing AI proposal generator...")
            try:
                AgoraDynamicHandler.generator = DynamicProposalGenerator()
                print("‚úÖ AI generator ready")
            except Exception as e:
                print(f"‚ùå Generator init failed: {e}")
        
        super().__init__(*args, directory=os.path.dirname(__file__), **kwargs)
    
    def do_GET(self):
        if self.path == '/':
            self.path = '/index.html'
        elif self.path == '/api/proposals':
            self.serve_api_proposals()
            return
        elif self.path == '/api/stats':
            self.serve_api_stats()
            return
        elif self.path == '/api/refresh':
            self.force_refresh()
            return
        
        super().do_GET()
    
    def force_refresh(self):
        """Force regeneration of proposals"""
        try:
            print("üîÑ Forcing proposal refresh...")
            AgoraDynamicHandler.last_generated = None
            proposals = self._get_proposals()
            
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.send_header('Access-Control-Allow-Origin', '*')
            self.end_headers()
            
            response = {
                "success": True,
                "proposals": len(proposals),
                "timestamp": datetime.now().isoformat()
            }
            self.wfile.write(json.dumps(response).encode())
            print(f"‚úÖ Generated {len(proposals)} new proposals")
            
        except Exception as e:
            print(f"‚ùå Refresh failed: {e}")
            self.send_error(500, str(e))
    
    def _get_proposals(self):
        """Get proposals (cached or generate new)"""
        now = datetime.now()
        
        # Regenerate every 5 minutes or if cache empty
        cache_valid = (
            AgoraDynamicHandler.last_generated and
            AgoraDynamicHandler.cached_proposals and
            (now - AgoraDynamicHandler.last_generated).seconds < 300
        )
        
        if not cache_valid:
            print("ü§ñ Generating fresh AI proposals...")
            try:
                count = 6  # Generate 4-6 proposals
                proposals = AgoraDynamicHandler.generator.generate_proposals(count)
                
                AgoraDynamicHandler.cached_proposals = proposals
                AgoraDynamicHandler.last_generated = now
                print(f"‚úÖ Generated {len(proposals)} proposals")
                
            except Exception as e:
                print(f"‚ùå Generation failed: {e}")
                # Fallback to basic proposals if AI fails
                AgoraDynamicHandler.cached_proposals = self._fallback_proposals()
        
        return AgoraDynamicHandler.cached_proposals
    
    def _fallback_proposals(self):
        """Fallback if AI generation fails"""
        return [
            {
                "id": "fallback-1",
                "title": "Loading AI-generated proposals...",
                "dao": "System",
                "status": "Pending",
                "riskLevel": "low",
                "sentiment": 0,
                "decision": "pending",
                "confidence": 0,
                "yesVotes": 0,
                "noVotes": 0,
                "processed": datetime.now().isoformat()
            }
        ]
    
    def serve_api_proposals(self):
        """Serve AI-generated proposals"""
        try:
            proposals = self._get_proposals()
            
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.send_header('Access-Control-Allow-Origin', '*')
            self.end_headers()
            
            response = {
                "proposals": proposals,
                "timestamp": datetime.now().isoformat(),
                "source": "ai-generated",
                "note": "Proposals dynamically generated by Bedrock Claude AI",
                "lastGenerated": AgoraDynamicHandler.last_generated.isoformat() if AgoraDynamicHandler.last_generated else None
            }
            self.wfile.write(json.dumps(response).encode())
            
        except Exception as e:
            print(f"‚ùå Error serving proposals: {e}")
            self.send_error(500, str(e))
    
    def serve_api_stats(self):
        """Calculate stats from current proposals"""
        try:
            proposals = self._get_proposals()
            
            total = len(proposals)
            automated = sum(1 for p in proposals if p.get('decision') == 'auto-approve')
            human_review = sum(1 for p in proposals if p.get('decision') == 'human-review')
            high_risk = sum(1 for p in proposals if p.get('riskLevel') in ['high', 'critical'])
            
            stats = {
                "totalProposals": total,
                "automatedDecisions": automated,
                "humanReview": human_review,
                "automationRate": round((automated / total * 100) if total > 0 else 0, 1),
                "highRiskCount": high_risk,
                "daosMonitored": 4,
                "uptime": "live",
                "source": "ai-generated",
                "lastRefresh": AgoraDynamicHandler.last_generated.isoformat() if AgoraDynamicHandler.last_generated else None
            }
            
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.send_header('Access-Control-Allow-Origin', '*')
            self.end_headers()
            
            self.wfile.write(json.dumps(stats).encode())
            
        except Exception as e:
            print(f"‚ùå Error serving stats: {e}")
            self.send_error(500, str(e))

def start_dashboard(port=8080):
    """Start the AI-powered dashboard"""
    
    dashboard_dir = os.path.dirname(__file__)
    os.chdir(dashboard_dir)
    
    print("üèõÔ∏è  AGORA AI-POWERED GOVERNANCE DASHBOARD")
    print("=" * 50)
    print("ü§ñ Using Bedrock Claude for dynamic proposal generation")
    print(f"üöÄ Starting server on port {port}...")
    print()
    print("üìä API Endpoints:")
    print(f"   GET /api/proposals  - AI-generated proposals")
    print(f"   GET /api/stats      - Live statistics")
    print(f"   GET /api/refresh    - Force new generation")
    print()
    
    try:
        with socketserver.TCPServer(("", port), AgoraDynamicHandler) as httpd:
            url = f"http://localhost:{port}"
            print(f"‚úÖ Dashboard live at: {url}")
            print("üîÑ Proposals auto-refresh every 5 minutes")
            print("ü§ñ Each proposal analyzed by Bedrock Claude AI")
            print("\nüõë Press Ctrl+C to stop")
            print("-" * 50)
            
            httpd.serve_forever()
            
    except KeyboardInterrupt:
        print("\nüõë Shutting down...")
    except OSError as e:
        if "Address already in use" in str(e):
            print(f"‚ùå Port {port} is already in use")
            print("üí° Try: python dashboard/server_dynamic.py --port 8081")
        else:
            print(f"‚ùå Error: {e}")

if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description="Agora AI-Powered Dashboard")
    parser.add_argument("--port", type=int, default=8080, help="Port (default: 8080)")
    
    args = parser.parse_args()
    start_dashboard(port=args.port)
